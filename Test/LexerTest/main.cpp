#include "../../CHTL/CHTLLexer/Lexer.h"
#include <iostream>
#include <vector>
#include <cassert>

void printToken(const Token& token) {
    std::cout << "Token(" << tokenTypeToString(token.type) << ", \"" << token.value << "\", "
              << token.line << ", " << token.column << ")" << std::endl;
}

int main() {
    std::string source = R"(
// This is a comment
html {
    head {
        title { "My Page" }
    }
    body {
        # This is a generator comment
        div {
            id: "main";
            class = box; // class can use unquoted literal
            text {
                "Hello, CHTL!"
            }
        }
    }
}
)";

    Lexer lexer(source);
    std::vector<Token> tokens = lexer.getAllTokens();

    std::vector<TokenType> expectedTypes = {
        // Line 2
        TokenType::Identifier, TokenType::OpenBrace,
        // Line 3
        TokenType::Identifier, TokenType::OpenBrace,
        // Line 4
        TokenType::Identifier, TokenType::OpenBrace, TokenType::String, TokenType::CloseBrace,
        // Line 5
        TokenType::CloseBrace,
        // Line 6
        TokenType::Identifier, TokenType::OpenBrace,
        // Line 7
        TokenType::GeneratorComment,
        // Line 8
        TokenType::Identifier, TokenType::OpenBrace,
        // Line 9
        TokenType::Identifier, TokenType::Colon, TokenType::String, TokenType::Semicolon,
        // Line 10
        TokenType::Identifier, TokenType::Equals, TokenType::Identifier, TokenType::Semicolon,
        // Line 11
        TokenType::Text, TokenType::OpenBrace,
        // Line 12
        TokenType::String,
        // Line 13
        TokenType::CloseBrace,
        // Line 14
        TokenType::CloseBrace,
        // Line 15
        TokenType::CloseBrace,
        // Line 16
        TokenType::CloseBrace,
        // Line 17
        TokenType::EndOfFile
    };

    // A simple way to handle the unquoted literal 'box' and the semicolon for now.
    // The lexer implementation needs refinement for these cases.
    // For now, let's adjust the test to what the current lexer produces.
    // My current lexer does not produce semicolons automatically. Let's assume they are required.
    // The unquoted literal 'box' will be tokenized as an Identifier. This is correct for the lexer level.

    std::cout << "Tokens generated by lexer:" << std::endl;
    for(const auto& token : tokens) {
        printToken(token);
    }

    std::cout << "\nExpected number of tokens: " << expectedTypes.size() << std::endl;
    std::cout << "Actual number of tokens: " << tokens.size() << std::endl;

    // The current lexer is very basic and might not produce the exact sequence above.
    // For example, it might not handle unquoted literals or optional semicolons correctly.
    // Let's run this and see what it produces, then refine the test and lexer.
    // This file is for testing, so it's okay to have this kind of investigative code.

    std::cout << "\nLexer test main created. Needs compilation and execution to verify." << std::endl;

    return 0;
}
