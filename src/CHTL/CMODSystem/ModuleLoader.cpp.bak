#include "ModuleLoader.h"
#include "../../Util/StringUtil/StringUtil.h"
#include <fstream>
#include <sstream>

namespace CHTL {
namespace CMOD {

ModuleLoader::ModuleLoader() {
    // 默认官方模块路径（编译器二进制文件所在目录的module文件夹）
    officialModulePath_ = "./module";
}

void ModuleLoader::addSearchPath(const String& path) {
    searchPaths_.push_back(path);
}

void ModuleLoader::setOfficialModulePath(const String& path) {
    officialModulePath_ = path;
}

void ModuleLoader::setUserModulePath(const String& path) {
    userModulePath_ = path;
}

Optional<ModuleData> ModuleLoader::loadModule(const String& moduleName) {
    auto modulePath = findModule(moduleName);
    if (!modulePath.has_value()) {
        return std::nullopt;
    }
    
    return loadModuleFromPath(modulePath.value());
}

Optional<ModuleData> ModuleLoader::loadModuleFromPath(const String& path) {
    namespace fs = std::filesystem;
    
    // 检查是否是.cmod文件
    if (Util::StringUtil::endsWith(path, ".cmod")) {
        return loadCMODFile(path);
    }
    
    // 检查是否是.cjmod文件
    if (Util::StringUtil::endsWith(path, ".cjmod")) {
        return loadCJMODFile(path);
    }
    
    // 检查是否是目录
    if (fs::is_directory(path)) {
        return loadFromDirectory(path);
    }
    
    // 检查是否是.chtl文件
    if (Util::StringUtil::endsWith(path, ".chtl")) {
        ModuleData data;
        // 读取单个CHTL文件作为模块
        std::ifstream file(path);
        if (!file) {
            return std::nullopt;
        }
        std::stringstream buffer;
        buffer << file.rdbuf();
        
        data.info.name = fs::path(path).stem().string();
        data.info.version = "1.0.0";
        data.info.type = ModuleType::CMOD;
        data.sourceFiles[fs::path(path).filename().string()] = buffer.str();
        
        return data;
    }
    
    return std::nullopt;
}

Optional<ModuleData> ModuleLoader::loadCMODFile(const String& filePath) {
    // TODO: 实现.cmod文件解包逻辑
    // .cmod是压缩的模块文件，需要使用miniz解压
    return std::nullopt;
}

Optional<ModuleData> ModuleLoader::loadCJMODFile(const String& filePath) {
    // TODO: 实现.cjmod文件加载逻辑
    return std::nullopt;
}

Optional<ModuleInfo> ModuleLoader::parseInfoFile(const String& filePath) {
    std::ifstream file(filePath);
    if (!file) {
        return std::nullopt;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    String content = buffer.str();
    
    return parseInfoBlock(content);
}

Optional<ModuleExports> ModuleLoader::parseExportFile(const String& filePath) {
    std::ifstream file(filePath);
    if (!file) {
        return std::nullopt;
    }
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    String content = buffer.str();
    
    return parseExportBlock(content);
}

ModuleInfo ModuleLoader::parseInfoBlock(const String& content) {
    ModuleInfo info;
    
    // 简单的[Info]块解析
    size_t infoStart = content.find("[Info]");
    if (infoStart == String::npos) {
        return info;
    }
    
    size_t blockStart = content.find("{", infoStart);
    size_t blockEnd = content.find("}", blockStart);
    if (blockStart == String::npos || blockEnd == String::npos) {
        return info;
    }
    
    String block = content.substr(blockStart + 1, blockEnd - blockStart - 1);
    
    // 解析键值对
    auto lines = Util::StringUtil::split(block, '\n');
    for (const auto& line : lines) {
        auto trimmed = Util::StringUtil::trim(line);
        if (trimmed.empty() || Util::StringUtil::startsWith(trimmed, "//")) {
            continue;
        }
        
        auto pos = trimmed.find('=');
        if (pos == String::npos) {
            continue;
        }
        
        String key = Util::StringUtil::trim(trimmed.substr(0, pos));
        String value = Util::StringUtil::trim(trimmed.substr(pos + 1));
        
        // 移除引号和分号
        if (Util::StringUtil::endsWith(value, ";")) {
            value = value.substr(0, value.length() - 1);
        }
        value = Util::StringUtil::trim(value);
        if ((Util::StringUtil::startsWith(value, "\"") && Util::StringUtil::endsWith(value, "\"")) ||
            (Util::StringUtil::startsWith(value, "'") && Util::StringUtil::endsWith(value, "'"))) {
            value = value.substr(1, value.length() - 2);
        }
        
        // 赋值
        if (key == "name") info.name = value;
        else if (key == "version") info.version = value;
        else if (key == "description") info.description = value;
        else if (key == "author") info.author = value;
        else if (key == "license") info.license = value;
        else if (key == "category") info.category = value;
        else if (key == "minCHTLVersion") info.minCHTLVersion = value;
        else if (key == "maxCHTLVersion") info.maxCHTLVersion = value;
        else if (key == "dependencies") {
            // 解析依赖列表
            if (!value.empty()) {
                info.dependencies = Util::StringUtil::split(value, ',');
                for (auto& dep : info.dependencies) {
                    dep = Util::StringUtil::trim(dep);
                }
            }
        }
    }
    
    return info;
}

ModuleExports ModuleLoader::parseExportBlock(const String& content) {
    ModuleExports exports;
    
    // 简单的[Export]块解析
    size_t exportStart = content.find("[Export]");
    if (exportStart == String::npos) {
        return exports;
    }
    
    size_t blockStart = content.find("{", exportStart);
    size_t blockEnd = content.find("}", blockStart);
    if (blockStart == String::npos || blockEnd == String::npos) {
        return exports;
    }
    
    String block = content.substr(blockStart + 1, blockEnd - blockStart - 1);
    
    // TODO: 实现完整的Export块解析
    // 这需要解析如：[Custom] @Style Name1, Name2;
    // [Template] @Element Name1;
    // 等等
    
    return exports;
}

Optional<String> ModuleLoader::findModule(const String& moduleName) {
    namespace fs = std::filesystem;
    
    // 1. 搜索官方模块目录
    if (!officialModulePath_.empty()) {
        auto found = findInPath(officialModulePath_, moduleName, true, true, true);
        if (found.has_value()) {
            return found;
        }
    }
    
    // 2. 搜索用户模块目录
    if (!userModulePath_.empty()) {
        auto found = findInPath(userModulePath_, moduleName, true, true, true);
        if (found.has_value()) {
            return found;
        }
    }
    
    // 3. 搜索当前目录
    auto found = findInPath(".", moduleName, true, true, true);
    if (found.has_value()) {
        return found;
    }
    
    // 4. 搜索额外的搜索路径
    for (const auto& path : searchPaths_) {
        auto found = findInPath(path, moduleName, true, true, true);
        if (found.has_value()) {
            return found;
        }
    }
    
    return std::nullopt;
}

Optional<String> ModuleLoader::findInPath(const String& path, const String& moduleName,
                                           bool searchCMOD, bool searchCHTL, bool searchCJMOD) {
    namespace fs = std::filesystem;
    
    if (!fs::exists(path)) {
        return std::nullopt;
    }
    
    // 检查是否是有序结构
    bool ordered = isOrderedStructure(path);
    
    if (ordered) {
        // 有序结构：CMOD/Cmod/cmod + CJMOD/CJmod/cjmod文件夹
        Vector<String> cmodDirs = {"CMOD", "Cmod", "cmod"};
        Vector<String> cjmodDirs = {"CJMOD", "CJmod", "cjmod"};
        
        if (searchCMOD || searchCHTL) {
            for (const auto& dir : cmodDirs) {
                String cmodPath = path + "/" + dir;
                if (fs::exists(cmodPath)) {
                    // 在CMOD文件夹中搜索
                    for (const auto& entry : fs::directory_iterator(cmodPath)) {
                        String filename = entry.path().filename().string();
                        String stem = entry.path().stem().string();
                        
                        if (stem == moduleName) {
                            if ((searchCMOD && Util::StringUtil::endsWith(filename, ".cmod")) ||
                                (searchCHTL && Util::StringUtil::endsWith(filename, ".chtl"))) {
                                return entry.path().string();
                            }
                            // 也可能是文件夹
                            if (entry.is_directory()) {
                                return entry.path().string();
                            }
                        }
                    }
                }
            }
        }
        
        if (searchCJMOD) {
            for (const auto& dir : cjmodDirs) {
                String cjmodPath = path + "/" + dir;
                if (fs::exists(cjmodPath)) {
                    // 在CJMOD文件夹中搜索
                    for (const auto& entry : fs::directory_iterator(cjmodPath)) {
                        String filename = entry.path().filename().string();
                        String stem = entry.path().stem().string();
                        
                        if (stem == moduleName && Util::StringUtil::endsWith(filename, ".cjmod")) {
                            return entry.path().string();
                        }
                        if (entry.is_directory() && stem == moduleName) {
                            return entry.path().string();
                        }
                    }
                }
            }
        }
    } else {
        // 无序结构：文件混杂在一起
        for (const auto& entry : fs::directory_iterator(path)) {
            String filename = entry.path().filename().string();
            String stem = entry.path().stem().string();
            
            if (stem == moduleName) {
                if ((searchCMOD && Util::StringUtil::endsWith(filename, ".cmod")) ||
                    (searchCHTL && Util::StringUtil::endsWith(filename, ".chtl")) ||
                    (searchCJMOD && Util::StringUtil::endsWith(filename, ".cjmod"))) {
                    return entry.path().string();
                }
                if (entry.is_directory()) {
                    return entry.path().string();
                }
            }
        }
    }
    
    return std::nullopt;
}

bool ModuleLoader::isOrderedStructure(const String& path) const {
    namespace fs = std::filesystem;
    
    Vector<String> cmodDirs = {"CMOD", "Cmod", "cmod"};
    Vector<String> cjmodDirs = {"CJMOD", "CJmod", "cjmod"};
    
    for (const auto& dir : cmodDirs) {
        if (fs::exists(path + "/" + dir)) {
            return true;
        }
    }
    
    for (const auto& dir : cjmodDirs) {
        if (fs::exists(path + "/" + dir)) {
            return true;
        }
    }
    
    return false;
}

ModuleData ModuleLoader::loadFromDirectory(const String& dirPath) {
    namespace fs = std::filesystem;
    
    ModuleData data;
    
    // 检查是否有src和info文件夹
    String srcPath = dirPath + "/src";
    String infoPath = dirPath + "/info";
    
    if (!fs::exists(srcPath) || !fs::exists(infoPath)) {
        return data;
    }
    
    // 获取模块名称（文件夹名称）
    String moduleName = fs::path(dirPath).filename().string();
    
    // 读取info文件
    String infoFile = infoPath + "/" + moduleName + ".chtl";
    if (fs::exists(infoFile)) {
        auto info = parseInfoFile(infoFile);
        if (info.has_value()) {
            data.info = info.value();
            data.info.modulePath = dirPath;
            data.info.infoFilePath = infoFile;
            data.info.srcPath = srcPath;
        }
        
        // 解析Export块
        auto exports = parseExportFile(infoFile);
        if (exports.has_value()) {
            data.exports = exports.value();
        }
    }
    
    // 读取src中的文件
    if (fs::exists(srcPath)) {
        // 加载主模块文件（如果存在）
        String mainFile = srcPath + "/" + moduleName + ".chtl";
        if (fs::exists(mainFile)) {
            std::ifstream file(mainFile);
            std::stringstream buffer;
            buffer << file.rdbuf();
            data.sourceFiles[moduleName + ".chtl"] = buffer.str();
        }
        
        // 加载子模块
        data.subModules = loadSubModules(srcPath);
    }
    
    return data;
}

Vector<SubModuleInfo> ModuleLoader::loadSubModules(const String& srcPath) {
    namespace fs = std::filesystem;
    
    Vector<SubModuleInfo> subModules;
    
    for (const auto& entry : fs::directory_iterator(srcPath)) {
        if (entry.is_directory()) {
            String subName = entry.path().filename().string();
            String subPath = entry.path().string();
            
            // 检查子模块是否有src和info文件夹
            if (fs::exists(subPath + "/src") && fs::exists(subPath + "/info")) {
                SubModuleInfo subInfo(subName, subPath);
                
                // 递归加载子模块的信息
                auto subData = loadFromDirectory(subPath);
                subInfo.info = subData.info;
                
                subModules.push_back(subInfo);
            }
        }
    }
    
    return subModules;
}

ModuleResolver::ModuleResolver() : officialPrefix_("chtl::") {}

Optional<ModuleResolver::ImportSpec> ModuleResolver::parseImport(const String& importStatement) {
    ImportSpec spec;
    
    // TODO: 实现完整的导入语句解析
    // 需要解析如：
    // [Import] @Chtl from path
    // [Import] [Custom] @Element Name from path as alias
    // [Import] @CJmod from path
    // 等等
    
    return spec;
}

String ModuleResolver::resolvePath(const String& basePath, const String& importPath) {
    namespace fs = std::filesystem;
    
    // 如果是绝对路径，直接返回
    if (fs::path(importPath).is_absolute()) {
        return importPath;
    }
    
    // 相对路径，基于basePath解析
    fs::path base(basePath);
    fs::path relative(importPath);
    fs::path resolved = base.parent_path() / relative;
    
    return resolved.string();
}

bool ModuleResolver::isOfficialModule(const String& path) const {
    return Util::StringUtil::startsWith(path, officialPrefix_);
}

String ModuleResolver::extractModuleName(const String& path) {
    namespace fs = std::filesystem;
    
    // 移除官方前缀
    String cleanPath = path;
    if (Util::StringUtil::startsWith(cleanPath, "chtl::")) {
        cleanPath = cleanPath.substr(6);
    }
    
    // 提取模块名称
    fs::path pathObj(cleanPath);
    return pathObj.stem().string();
}

} // namespace CMOD
} // namespace CHTL
