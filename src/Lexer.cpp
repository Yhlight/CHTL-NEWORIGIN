#include "Lexer.h"
#include <cctype>
#include <iostream>

Lexer::Lexer(const std::string& source) : source(source) {}

std::vector<Token> Lexer::tokenize() {
    std::vector<Token> tokens;
    while (!isAtEnd()) {
        Token token = nextToken();
        if (token.type == TokenType::Unknown && token.value.empty()) {
            // Skip empty unknown tokens that might be generated by whitespace handling
            continue;
        }
        tokens.push_back(token);
        if (token.type == TokenType::EndOfFile) {
            break;
        }
    }
    return tokens;
}

void Lexer::skipWhitespaceAndComments() {
    while (!isAtEnd()) {
        char c = peek();
        if (isspace(c)) {
            if (c == '\n') line++;
            advance();
        } else if (c == '/' && (current + 1 < source.length() && source[current+1] == '/')) {
            // Single line comment
            while (!isAtEnd() && peek() != '\n') {
                advance();
            }
        } else if (c == '/' && (current + 1 < source.length() && source[current+1] == '*')) {
            // Multi-line comment
            advance(); // Consume /
            advance(); // Consume *
            while (!isAtEnd()) {
                if (peek() == '*' && (current + 1 < source.length() && source[current+1] == '/')) {
                    advance(); // Consume *
                    advance(); // Consume /
                    break;
                }
                if (peek() == '\n') line++;
                advance();
            }
        }
        else {
            break;
        }
    }
}

Token Lexer::nextToken() {
    skipWhitespaceAndComments();

    if (isAtEnd()) {
        return {TokenType::EndOfFile, "", line};
    }

    char c = peek();

    // Handle generator comments: # comment content
    if (c == '#') {
        advance(); // consume '#'
        std::string value;
        if (peek() == ' ') {
            advance(); // consume space
        }
        while(!isAtEnd() && peek() != '\n') {
            value += advance();
        }
        return {TokenType::Comment, value, line};
    }

    // Handles identifiers and unquoted literals
    if (isalpha(c) || c == '_') {
        std::string value;
        value += advance();
        while (!isAtEnd() && (isalnum(peek()) || peek() == '_' || peek() == '-')) {
            value += advance();
        }
        if (value == "inherit") {
            return {TokenType::Inherit, value, line};
        }
        if (value == "delete") {
            return {TokenType::Delete, value, line};
        }
        if (value == "from") {
            return {TokenType::From, value, line};
        }
        return {TokenType::Identifier, value, line};
    }

    if (c == '"' || c == '\'') {
        return handleStringLiteral();
    }

    // Handles single-character tokens
    switch (c) {
        case '{': advance(); return {TokenType::LeftBrace, "{", line};
        case '}': advance(); return {TokenType::RightBrace, "}", line};
        case ':': advance(); return {TokenType::Colon, ":", line};
        case ';': advance(); return {TokenType::Semicolon, ";", line};
        case '=': advance(); return {TokenType::Equals, "=", line};
        case '[': advance(); return {TokenType::LeftBracket, "[", line};
        case ']': advance(); return {TokenType::RightBracket, "]", line};
        case '(': advance(); return {TokenType::LeftParen, "(", line};
        case ')': advance(); return {TokenType::RightParen, ")", line};
        case '@': advance(); return {TokenType::At, "@", line};
        case ',': advance(); return {TokenType::Comma, ",", line};
    }

    // Fallback for unquoted literals that don't start with a letter (e.g. numbers)
    if (!isspace(c)) {
        std::string value;
        value += advance();
        while (!isAtEnd() && !isspace(peek()) && peek() != '{' && peek() != '}' && peek() != ':' && peek() != ';' && peek() != '=') {
            value += advance();
        }
        // This could be an identifier or a value. The parser will know.
        return {TokenType::Identifier, value, line};
    }

    advance();
    // Return an empty unknown token that will be skipped.
    return {TokenType::Unknown, "", line};
}


Token Lexer::handleStringLiteral() {
    char quote_type = advance(); // Consume opening quote
    std::string value;
    while (!isAtEnd() && peek() != quote_type) {
        if (peek() == '\n') line++;
        value += advance();
    }

    if (isAtEnd()) {
        // Unterminated string
        return {TokenType::Unknown, value, line};
    }

    advance(); // consume closing quote
    return {TokenType::StringLiteral, value, line};
}

char Lexer::peek() {
    if (isAtEnd()) return '\0';
    return source[current];
}

char Lexer::advance() {
    if (!isAtEnd()) {
        current++;
    }
    return source[current - 1];
}

bool Lexer::isAtEnd() {
    return current >= source.length();
}
