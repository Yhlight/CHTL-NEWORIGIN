#include "packer.h"
#include <iostream>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>
#include "libzippp/libzippp.h"
#include "CHTL/CHTLLoader/Loader.h"
#include "CHTL/CHTLLexer/Lexer.h"
#include "CHTL/CHTLParser/Parser.h"
#include "CHTL/CHTLManage/TemplateManager.h"

namespace fs = std::filesystem;

// Helper function to recursively add files to the zip archive.
void add_directory_to_archive(libzippp::ZipArchive& archive, const fs::path& dir_path, const fs::path& base_path) {
    for (const auto& entry : fs::recursive_directory_iterator(dir_path)) {
        const auto& path = entry.path();
        auto relative_path = fs::relative(path, base_path);

        if (fs::is_directory(path)) {
            archive.addEntry(relative_path.string() + "/");
        } else if (fs::is_regular_file(path)) {
            archive.addFile(relative_path.string(), path.string());
        }
    }
}

// Helper function to parse all module sources and populate the template manager.
void parse_module_sources(const fs::path& src_dir, TemplateManager& manager) {
    for (const auto& entry : fs::recursive_directory_iterator(src_dir)) {
        if (entry.is_regular_file() && entry.path().extension() == ".chtl") {
            try {
                std::string content = Loader::loadFile(entry.path().string());
                Lexer lexer(content);
                Parser parser(lexer, entry.path().string());
                parser.parse();
                manager.merge(parser.templateManager);
            } catch (const std::exception& e) {
                std::cerr << "Warning: Could not parse '" << entry.path().string() << "': " << e.what() << std::endl;
            }
        }
    }
}

// Helper function to generate the [Export] block from the template manager.
std::string generate_export_block(const TemplateManager& manager) {
    std::stringstream ss;
    ss << "\n\n// Auto-generated by cmod_packer\n";
    ss << "[Export]\n{\n";
    auto process_map = [&](const auto& template_map, const std::string& type_qualifier) {
        for (const auto& ns_pair : template_map) {
            for (const auto& tmpl_pair : ns_pair.second) {
                const auto& tmpl_name = tmpl_pair.first;
                const auto* tmpl_node = tmpl_pair.second.get();
                std::string meta_qualifier = tmpl_node->isCustom ? "[Custom]" : "[Template]";
                ss << "    " << meta_qualifier << " " << type_qualifier << " " << tmpl_name << ";\n";
            }
        }
    };
    process_map(manager.getStyleTemplates(), "@Style");
    process_map(manager.getElementTemplates(), "@Element");
    process_map(manager.getVarTemplates(), "@Var");
    ss << "}\n";
    return ss.str();
}

// Implementation of the core packer logic.
int pack_cmod(const std::filesystem::path& source_dir, const std::filesystem::path& output_file) {
    if (!fs::is_directory(source_dir)) {
        std::cerr << "Error: Source directory does not exist or is not a directory." << std::endl;
        return 1;
    }

    fs::path src_subdir = source_dir / "src";
    fs::path info_subdir = source_dir / "info";
    std::string module_name = source_dir.filename().string();
    fs::path info_file_path = info_subdir / (module_name + ".chtl");

    if (!fs::is_directory(src_subdir) || !fs::is_directory(info_subdir)) {
        std::cerr << "Error: Source directory must contain 'src' and 'info' subdirectories." << std::endl;
        return 1;
    }
    if (!fs::is_regular_file(info_file_path)) {
        std::cerr << "Error: Main info file '" << info_file_path.string() << "' not found." << std::endl;
        return 1;
    }

    TemplateManager manager;
    parse_module_sources(src_subdir, manager);
    std::string export_block = generate_export_block(manager);
    std::string info_content = Loader::loadFile(info_file_path.string());
    info_content += export_block;

    try {
        libzippp::ZipArchive zf(output_file.string());
        zf.open(libzippp::ZipArchive::New);
        add_directory_to_archive(zf, src_subdir, source_dir);
        fs::path relative_info_path = fs::relative(info_file_path, source_dir);
        zf.addData(relative_info_path.string(), info_content.c_str(), info_content.size());
        zf.close();
        std::cout << "Successfully created CMOD package: " << output_file.string() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error creating CMOD package: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
